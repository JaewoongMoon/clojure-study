(ns pegthing.core
  (require [clojure.set :as set])
  (:gen-class))

; Time to build a terminal implementation of Peg Thing using everything I've learned so far: immutable data structures, lazy sequences, pure functions, recursion.
; Doing this will help you understand how to combine these concepts and techniques to solve larger problems. Most important, you'll learn how to model the changes that result from each move a player makes without having to mutate objects like you would in OOP.

; CODE ORGANIZATION
; The program has to handle four major tasks, 
; 1. Creating a new board
; 2. Returning a board with the result of the player's move
; 3. Representing a board textually
; 4. Handling user interaction

; Two more points about the organization: First, the code has a basic architecture, or conceptual organization, of two layers.
; The top layer consists of the functions for handling user interaction. These functions produce all of the programs's side effects, printing out the board and presenting prompts for player interaction. The functions in this layer use the functions in the bottom layer to create a new board, make moves, and create a textual representation, but the functions in the bottom layer don't use those in the top layer at all. 

; Second, I've tried as much as possible to decompose tasks into small functions so that each does one tiny, understandable task. Some of these functions are used by only one other function. I find this helpful because it lets me name each tiny subtask, allowing me to better express the intention of the code.

(declare successful-move prompt-move game-over query-rows)

; Creating the Board
; The data structure you use to represent the board should make it easy for you to print the board, check whether a player has make a valid move, actually perform a move, and check wheter the game is over. You could structure the board in many ways to allow these tasks. In this case, you'll represent the board using a map with numerical keys coreesponding to each board position and values containing information about that position's connections. The map will also contain a :rows key, storing the total number of rows.
; Here's the data structure build to represent it

{
1 {:pegged true, :connections {6 3, 4 2}},
2 {:pegged true, :connections {9 5, 7 4}},
3 {:pegged true, :connections {10 6, 8 5}},
4 {:pegged true, :connections {13 6, 11 7, 6 5, 1 2}},
5 {:pegged true, :connections {14 9, 12 8}},
6 {:pegged true, :connections {15 10, 13 9, 4 5, 1 3}},
7 {:pegged true, :connections {9 8, 2 4}},
8 {:pegged true, :connections {10 9, 3 5}},
9 {:pegged true, :connections {7 8, 2 5}},
10 {:pegged true, :connections {8 9, 3 6}},
11 {:pegged true, :connections {13 12, 4 7}},
12 {:pegged true, :connections {14 13, 5 8}},
13 {:pegged true, :connections {15 14, 11 12, 6 9, 4 8}},
14 {:pegged true, :connections {12 13, 5 9}},
15 {:pegged true, :connections {13 14, 6 10}},
:rows 5
}

; You might be wondering why, when you play the game, each position is represented by a letter but here the positions are represented by numbers. Using numbers for the internal representation allows you to take advantage of some mathmatical properties of the board layout when validating and making moves. 
; Letters, on the other hand, are better for display because they take up only on character space.
                                       

; The first few expressions in this section of the code deal with triangular numbers. Triangular number are generated by adding the first n natural numbers. 
; The first triangular number is 1, the second is 3(1 + 2), the third is 6 (1 + 2+ 3), and so on. These numbers line up nicely with the position numbers at the end of every row on the board, which will turn out to be a very useful property.
; First, you define the function tri*, which can create a lazy sequence of triangular numbers;

(defn tri*
  "Generates lazy sequence of triangular numbers"
  ([] (tri* 0 1))
  ([sum n]
   (let [new-sum (+ sum n)]
     (cons new-sum (lazy-seq (tri* new-sum (inc n)))))))

;(tri*)

; The next expression calls tri*, actually creating the lazy sequence and binding it to tri:
(def tri (tri*))


(take 5 tri)
; -> (1 3 6 10 15)

(take 3 tri)

; And the next few functions operate on the sequence of triangular numbers.
; triangular? figures out if its argument is in the tri lazy sequence.
; It works by using take-while to create a sequence of triangular numbers whose last element is a triangular number that's less than or equal to the argument.
; Then it compares the last element to the argument:
(defn triangular?
  "Is the number triangular? e.g. 1, 3, 6, 10, 15, etc"
  [n]
  (= n (last (take-while #(>= n %) tri))))

(triangular? 5)
; -> false

(triangular? 6)
; -> true

; take-while traverses the given sequence and applying the predicate function to each element.
(take-while #(>= 6 %) tri)
; -> 6

; Next, there's row-tri, which take a row number and gives you the triangular number at the end of that row:
(defn row-tri 
  "The triangular number at the end of row n"
  [n]
  (last (take n tri)))

(row-tri 1)
; -> 1
(row-tri 2)
; -> 3
(row-tri 3)
; -> 6

; Lastly, there's row-num, which takes a board position and returns the row that it belongs to:

(defn row-num
  "Returns row number the position belongs to: pos 1 in row 1,
positions 2 and 3 in row 2, etc"
  [pos]
  (inc (count (take-while #(> pos %) tri))))

(row-num 1)
; ->1
(row-num 2)
; ->2
(row-num 4)
; -> 3

; connect, which is used to actually form a mutual connection between two positions :

(defn connect
  "Form a mutual connection between two positions"
  [board max-pos pos neighbor destination]
  (if (<= destination max-pos)
    (reduce (fn [new-board [p1 p2]]
              (assoc-in new-board [p1 :connections p2] neighbor))
            board
            [[pos destination] [destination pos]])
    board))

(connect {} 15 1 2 4)
; -> {1 {:connections {4 2}}, 4 {:connections {1 2}}}

; The first thing connect does is check whether the destination is actually a position on the board by confirming that it's less thatn the board's max position.
; For example, if you have five rows, the max position is 15. However, when the game board is created, the connect function will be called with arguments like (connect {} 15 7 16 22). The if statement at the beginning of connect makes sure your program doesn't allow such outrageous connections, and simply returns the unmodified board when you ask it to do something silly.

; The anonymous function passed to reduce uses a function, assoc-in, which you haven't seen before. Whereas the function get-in lets you look up values in nested maps, assoc-in lets you return a new map with the given value at the specified nesting. 
(assoc-in {} [:cookies :monster :vocals] "Finntroll")

(get-in {:cookies {:monster {:vocals "Finntroll"}}} [:cookies :monster])

(assoc-in {} [1 :connections 4] 2)

(defn connect-right
  [board max-pos pos]
  (let [neighbor (inc pos)
        destination (inc neighbor)]
    (if-not (or (triangular? neighbor) (triangular? pos))
      (connect board max-pos pos neighbor destination)
      board)))

(defn connect-down-left
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ row pos)
        destination (+ 1 row neighbor)]
    (connect board max-pos pos neighbor destination)))

(defn connect-down-right
  [board max-pos pos]
  (let [row (row-num pos)
        neighbor (+ 1 row pos)
        destination (+ 2 row neighbor)]
    (connect board max-pos pos neighbor destination)))

; These functions each take the board's max position and a board position and use a little triangle math to figure out which numbers to feed to connect. 

(connect-down-left {} 15 1)
; -> {1 {:connections {4 2}}, 4 {:connections {1 2}}}

(connect-down-right {} 15 3)

; The next function, add-pos, is interesting because it actually reduces on a vector of functions, applying each in turn to build up the resulting board. But first it updates the board to indicate that a peg is in the given position.

(defn add-pos
  "Pegs the position and performs connections"
  [board max-pos pos]
  (let [pegged-board (assoc-in board [pos :pegged] true)]
    (reduce (fn [new-board connection-creation-fn]
              (connection-creation-fn new-board max-pos pos))
            pegged-board
            [connect-right connect-down-left connect-down-right])))

; It's like this function saying, in the pegged-board binding, 
; "Add a peg to the board at position X."
; and try to connect position X to alegal, rightward position.
; Take the board that results that operation, and try to connect position X to a lgal, down-left position.
; Finally, take the board that results from that operation, and try to connect position X to a legal, down-right position. Return the resulting board. 
 
(defn clean 
  [text]
  (reduce (fn [string string-fn] (string-fn string))
          text
          [s/trim #(s/replace % #"lol" "LOL")]))

; This redefiniting of clean reduces a vector of functions by applying the first function, s/trim, to an initial string, then applying the next function, the anonymous function #(s/replace % #"lol" "LOL"), to the result 

(defn new-board
  "Creates a new board with the given number of rows"
  [rows]
  (let [initial-board {:rows rows}
        max-pos (row-tri rows)]
    (reduce (fn [board pos] (add-pos board max-pos pos))
            initial-board
            (range 1 (inc max-pos)))))

; The code first creates the initial, empty board and gets the max position.
; Assuming that you're using five rows, the max position will be 15.
; Next, the function uses (range 1 (inc max-pos)) to get a list of numbers from 1 to 15, otherwise known as the board's positions. 
; Finally, it reduces over the list of positions.  
; Each iteration of the reduction calls (add-pos board max-pos pos),
; which, as you saw earlier, takes a existing board and return a new one with the position added. 


;; 2. MOVING PEGS

(defn pegged?
  "Does the position have a peg in it?"
  [board pos]
  (get-in board [pos :pegged]))

(defn remove-peg
  "Take the peg at given position out of the board"
  [board pos]
  (assoc-in board [pos :pegged] false))

(defn place-peg
  "Put a peg in the board at given position"
  [board pos]
  (assoc-in board [pos :pegged] true))

(defn move-peg
  "Take peg out of p1 and place it in p2"
  [board p1 p2]
  (place-peg (remove-peg board p1) p2)
)
(defn valid-moves
  "Return a map of all valid moves for pos, where the key is the destination and the value is the jumped position"
  [board pos]
  (into {}
       (filter (fn [[destination jumped]]
                 (and (not (pegged? board destination))
                      (pegged? board jumped)))
               (get-in board [pos :connections]))))

; This code goes through each of the given position's connections 
; and tests whether the destination position is empty and the jumped position has a peg. 

(defn valid-move?
  "Return jumped posiiton if the move from p1 to p2 is valid, 
nil otherwise"
  [board p1 p2]
  (get (valid-moves board p1) p2))

(defn make-move
  "Move peg from p1 to p2, removing jumped peg"
  [board p1 p2]
  (if-let [jumped (valid-move? board p1 p2)]
    (move-peg (remove-peg board jumped) p1 p2)))

(defn can-move?
  "Do any of the pegged positions have valid moves?"
  [board]
  (some (comp not-empty (partial valid-moves board))
        (map first (filter #(get (second %) :pegged) board))))


